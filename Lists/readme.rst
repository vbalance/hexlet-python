Python: Списки
=====================================

.. contents::

01 - Вес Хэмминга (hamming_weight.py)
-------------------------------------

Вес Хэмминга это количество единиц в двоичном представлении числа.
Реализуйте функцию hamming_weight, которая считает вес Хэмминга.

Примеры:

    >>> hamming_weight(0)
    0
    >>> hamming_weight(4)
    1
    >>> hamming_weight(101)
    4

02 - Треугольник Паскаля (triangle.py)
--------------------------------------

Треугольник Паскаля — бесконечная таблица биномиальных коэффициентов, имеющая треугольную форму. В этом треугольнике на вершине и по бокам стоят единицы. Каждое число равно сумме двух расположенных над ним чисел. Строки треугольника симметричны относительно вертикальной оси::

    0:      1
    1:     1 1
    2:    1 2 1
    3:   1 3 3 1
    4:  1 4 6 4 1

Напишите функцию triangle(), которая возвращает указанную строку треугольника Паскаля в виде списка.

Пример::

    >>> triangle(0)
    [1]
    >>> triangle(4)
    [1, 4, 6, 4, 1]

03 - Увеличение двумерного списка (enlarge.py)
----------------------------------------------

Реализуйте функцию enlarge(), которая принимает изображение в виде двумерного списка строк и увеличивает его в два раза, то есть удваивает каждый символ по горизонтали и вертикали.

    >>> def show(image):
    ...     for line in image:
    ...         print(line)
    ...
    >>> dot = ['@']
    >>> show(enlarge(dot))
    @@
    @@
    >>> frame = [
    ...     '****',
    ...     '*  *',
    ...     '*  *',
    ...     '****'
    ... ]
    >>> show(frame)
    ****
    *  *
    *  *
    ****
    >>> show(enlarge(frame))
    ********
    ********
    **    **
    **    **
    **    **
    **    **
    ********
    ********

| Подсказка.
Если вам потребуется склеить список строк в одну строку, воспользуйтесь таким методом:

    >>> chunks = ["Hello", " ", "World", "!"]
    >>> ''.join(chunks)
    'Hello World!'

04 - Длина последнего слова (length_of_last_word.py)
------------------------------

Реализуйте функцию length_of_last_word(), которая возвращает длину последнего слова переданной на вход строки. Словом считается любая последовательность не содержащая пробелы, символы перевода строки \n и табуляции \t.

    >>> length_of_last_word('')
    0
    >>> length_of_last_word('man in Black')
    5
    >>> length_of_last_word('hello, world!     ')
    6
    >>> length_of_last_word('hello\t\nworld')
    5

05 - Чанкование (chunked.py)
----------------------------

Реализуйте функцию chunked, которая принимает на вход число и последовательность. Число задает размер чанка (куска). Функция должна вернуть список, состоящий из чанков указанной размерности. При этом список должен делиться на куски-списки, строка — на строки, кортеж — на кортежи!

    >>> chunked(2, ['a', 'b', 'c', 'd'])
    [['a', 'b'], ['c', 'd']]
    >>> chunked(3, ['a', 'b', 'c', 'd'])
    [['a', 'b', 'c'], ['d']]
    >>> chunked(3, 'foobar')
    ['foo', 'bar']
    >>> chunked(10, (42,))
    [(42,)]

06 - Возрастающая последовательность (is_continuous_sequence.py)
----------------------------------------------------------------

Реализуйте функцию is_continuous_sequence(), которая проверяет, является ли переданная последовательность целых чисел возрастающей непрерывно (не имеющей пропусков чисел). Например, последовательность [4, 5, 6, 7] — непрерывная, а [0, 1, 3] — нет. Последовательность может начинаться с любого числа. Главное условие — отсутствие пропусков чисел. Последовательность из одного числа не может считаться возрастающей.

    >>> is_continuous_sequence([10, 11, 12, 13])
    True
    >>> is_continuous_sequence([-5, -4, -3])
    True
    >>> is_continuous_sequence([10, 11, 12, 14, 15])
    False
    >>> is_continuous_sequence([1, 2, 2, 3])
    False
    >>> is_continuous_sequence([7])
    False
    >>> is_continuous_sequence([])
    False

07 - Самая длинная подстрока (find_longest_length.py)
-----------------------------------------------------

Реализуйте функцию find_longest_length(), принимающую на вход строку и возвращающую длину максимальной последовательности из неповторяющихся символов. Подстрока может состоять из одного символа. Например в строке qweqrty, можно выделить следующие подстроки: qwe, weqrty. Самой длинной будет weqrty, а её длина — 6 символов.

    >>> find_longest_length('abcdeef')
    5
    >>> find_longest_length('jabjcdel')
    7

08 - Сравнение версий (compare_version.py)
------------------------------------------

Реализуйте функцию compare_version(), которая сравнивает переданные версии version1 и version2. Если version1 > version2, то функция должна вернуть 1, если version1 < version2, то -1, если же version1 = version2 — 0.

Версия — это строка, в которой два числа (мажорная и минорные версии) разделены точкой, например: 12.11. Важно понимать, что версия — это не число с плавающей точкой, а несколько чисел не связанных между собой. Проверка на больше/меньше производится сравнением каждого числа независимо. Поэтому версия 0.12 больше версии 0.2.

Пример порядка версий::

    0.1 < 1.1 < 1.2 < 1.11 < 13.37
    >>> compare_version("0.1", "0.2")
    -1
    >>> compare_version("0.2", "0.1")
    1
    >>> compare_version("4.2", "4.2")
    0

Подробнее о версиях: http://semver.org/lang/ru/

Подсказки.
Разобрать строку на части, разделённые некоторой подстрокой, можно так:

    >>> 'foo::bar::baz'.split('::')
    ['foo', 'bar', 'baz']

09 - Список диапазонов (summary_ranges.py)
------------------------------------------

Реализуйте функцию summary_ranges(), которая находит в списке непрерывные возрастающие последовательности чисел и возвращает список с их перечислением.

    >>> summary_ranges([])
    []
    >>> summary_ranges([1])
    []
    >>> summary_ranges([1, 2, 3])
    ['1->3']
    >>> summary_ranges([0, 1, 2, 4, 5, 7])
    ['0->2', '4->5']
    >>> summary_ranges([110, 111, 112, 111, -5, -4, -2, -3, -4, -5])
    ['110->112', '-5->-4']

10 - Транспонирование матриц (transposed.py)
--------------------------------------------

Транспонированием матрицы называется операция, при которой столбцы матрицы становятся строками, а строки становятся столбцами. Представим некую двумерную матрицу::

    1 2 3
    4 5 6
    7 8 9

После транспонирования матрица будет выглядеть так::

    1 4 7
    2 5 8
    3 6 9

Транспонирование производилось по главной диагонали, то есть 1, 5 и 9 остались на своих местах, а сама матрица оказалась как бы повёрнута на 180 градусов относительно этой воображаемой диагональной оси.

Реализуйте функцию transposed(), которая должна принимать матрицу в виде списка списков и возвращать транспонированную матрицу (новый список списков).

Имейте в виду, что хоть в математике и транспонируют строго квадратные матрицы, ваша функция transposed() должна быть более "всеядной": она должна уметь переворачивать и прямоугольные матрицы!

    >>> transposed([[1]])
    [[1]]
    >>> transposed([[1, 2], [3, 4]])
    [[1, 3], [2, 4]]
    >>> transposed([[1, 2], [3, 4], [5, 6]])
    [[1, 3, 5], [2, 4, 6]]
    >>> transposed(transposed([[1, 2]])) == [[1, 2]]
    True

11 - Чанкование потока
-------------------------

12 - Зеркалирование матрицы
------------------------------

13 - Сумма интервалов
------------------------

14 - Обратная польская запись
--------------------------------

15 - Улитка
--------------

16 - Умножение матриц
------------------------

17 - Копилка
---------------
